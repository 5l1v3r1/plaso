#!/usr/bin/python
# -*- coding: utf-8 -*-
# Copyright 2013 The Plaso Project Authors.
# Please see the AUTHORS file for details on individual authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""This file contains the Property List (Plist) Parser.

Plaso's engine calls PlistParser when it encounters Plist files to be processed.
"""

import logging
import os

from binplist import binplist

# Need to import plist to ensure plugins are registered.
from plaso import plist  # pylint: disable=W0611

from plaso.lib import errors
from plaso.lib import parser
from plaso.lib import plist_interface
from plaso.lib import utils


class PlistParser(parser.PlasoParser):
  """Deserializes plists; yields event.PlistEvent generated by a PlistPlugin.

  The Plaso engine calls parsers by their Parse() method. This parser's
  Parse() has GetTopLevel() which deserializes plist files using the binplist
  library and calls plugins (PlistPlugin) registered through the
  plist_interface by their Process() to yield PlistEvent objects back
  to the engine.

  Plugins are how this parser understands the content inside a plist file,
  each plugin holds logic specific to a particular plist file. See the
  plist_interface and plist/ directory for examples of how plist plugins are
  implemented.
  """

  NAME = 'plist'

  def __init__(self, pre_obj, config):
    super(PlistParser, self).__init__(pre_obj, config)
    self._plugins = plist_interface.GetPlistPlugins(pre_obj)

  def GetTopLevel(self, filehandle):
    """Returns the deserialized content of a plist as a dictionary object.

    Args:
      filehandle: This is a file-like object pointing to the plist.

    Returns:
      Dictionary object representing the contents of the plist.
    """
    file_size = getattr(filehandle, 'size', 0)
    if not file_size:
      stat = filehandle.Stat()
      file_size = getattr(stat, 'size', 0)

    if file_size > 50000000:  # 50MB is 10x larger than any plist seen to date.
      raise errors.UnableToParseFile(
          u'[PLIST] Plist file is more than 50MB: {} bytes'.format(file_size))

    try:
      bpl = binplist.BinaryPlist(filehandle)
      top_level_object = bpl.Parse()
    except binplist.FormatError as e:
      raise errors.UnableToParseFile(
          u'[PLIST] File is not a plist:{}'.format(utils.GetUnicodeString(e)))
    except OverflowError as e:
      raise errors.UnableToParseFile(
          u'[PLIST] error processing:{} Error:{}'.format(filehandle, e))

    if not bpl:
      raise errors.UnableToParseFile(
          u'[PLIST] File is not a plist:{}'.format(utils.GetUnicodeString(e)))

    if bpl.is_corrupt:
      logging.warning(u'[PLIST] bpl found corruption in: %s', filehandle.name)

    return top_level_object

  def Parse(self, filehandle):
    """Parse and extract values from a plist file.

    Args:
      filehandle: This is a file like object or a PFile object.

    Yields:
    An event.PlistEvent containing information extracted from a Plist.
    """
    top_level_object = self.GetTopLevel(filehandle)
    if not top_level_object:
      raise errors.UnableToParseFile(
          u'[PLIST] couldn\'t parse: %s.  Skipping.' % filehandle.name)

    plist_name = os.path.basename(filehandle.name)

    for plugin in self._plugins:
      try:
        for evt in plugin.Process(plist_name, top_level_object):
          yield evt
      except errors.WrongPlistPlugin as e:
        logging.debug(u'[PLIST] Wrong Plugin:{} for:{}'.format(e[0], e[1]))
